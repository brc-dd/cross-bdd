name: Test

on:
  workflow_call:
    inputs:
      deno_versions:
        type: string
      node_versions:
        type: string
      bun_versions:
        type: string

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
      - uses: denoland/setup-deno@v2
      - uses: pnpm/action-setup@v4
        with:
          version: latest
      - run: |
          set -euo pipefail
          shopt -s globstar nullglob extglob

          pm=""
          [[ -f deno.lock ]] && pm="deno"
          [[ -z "${pm}" && -f pnpm-lock.yaml ]] && pm="pnpm"
          [[ -z "${pm}" && -f bun.lock ]] && pm="bun"
          [[ -z "${pm}" ]] && { echo "Unsupported package manager. Exiting." >&2; exit 1; }

          TASKS="$(NO_COLOR=1 deno task 2>/dev/null || true)"

          declare -a NPM_DEPS=()
          declare -a JSR_DEPS=()

          if [[ -f deno.json ]]; then
            while IFS= read -r dep; do
              [[ -n "$dep" ]] && NPM_DEPS+=("$dep")
            done < <(jq -r '.imports // {} | to_entries[]? | select(.value|startswith("npm:")) | .value[4:]' deno.json 2>/dev/null || true)
            while IFS= read -r dep; do
              [[ -n "$dep" ]] && JSR_DEPS+=("$dep")
            done < <(jq -r '.imports // {} | to_entries[]? | select(.value|startswith("jsr:")) | .value' deno.json 2>/dev/null || true)
          fi

          install_deps() {
            local rt=$1
            [[ -d node_modules ]] && return 0

            case "${pm}:${rt}" in
            deno:deno)
              return 0
              ;;
            deno:*)
              [[ -f package.json ]] || echo '{ "type": "module" }' >package.json
              ((${#NPM_DEPS[@]})) && "$rt" add "${NPM_DEPS[@]}"
              if ((${#JSR_DEPS[@]})); then
                if [[ "$rt" == "bun" ]]; then
                  bun x jsr add "${JSR_DEPS[@]#jsr:}"
                else
                  pnpm add "${JSR_DEPS[@]}"
                fi
              fi
              ;;
            *:*)
              "$rt" install
              ;;
            esac
          }

          run_task() {
            local rt=$1 task=$2 fallback="${3:-}"

            install_deps "$rt"

            if grep -qE "^- ${task}(\b|[[:space:]])" <<<"$TASKS"; then
              case "${rt}" in
              deno) deno task "$task" ;;
              pnpm) pnpm run "$task" ;;
              bun) bun run "$task" ;;
              esac
            elif [[ -n "$fallback" ]]; then
              eval "$fallback"
            fi
          }

          run_task "$pm" build
          run_task "$pm" check:only

          if [[ -d "./dist" ]]; then
            (cd dist && pnpm pack --out=pkg.tgz >/dev/null)
            NPM_DEPS=("./dist/pkg.tgz" "${NPM_DEPS[@]}")
          fi

          TEST_FILES=(**/*.test.ts)

          run_tests() {
            local rt=$1 ver=$2

            git reset --hard HEAD
            git clean -fd
            rm -rf node_modules

            case "$rt" in
            deno)
              deno upgrade "$ver"
              run_task deno test:deno "deno test -A ${TEST_FILES[*]}"
              ;;
            node)
              pnpm env use --global "$ver"
              run_task pnpm test:node "pnpx tsx --test ${TEST_FILES[*]}"
              ;;
            bun)
              pnpm add --dangerously-allow-all-builds -g "bun@$ver"
              run_task bun test:bun "bun test ${TEST_FILES[*]}"
              ;;
            esac
          }

          run_versions() {
            local rt=$1 versions=$2
            [[ -z "$versions" ]] && return 0
            for v in $versions; do
              run_tests "$rt" "$v"
            done
          }

          run_versions deno "${{ inputs.deno_versions }}"
          run_versions node "${{ inputs.node_versions }}"
          run_versions bun "${{ inputs.bun_versions }}"
